{"version":3,"file":"urql.min.js","sources":["../src/context.ts","../src/hooks/state.ts","../src/hooks/useMutation.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/cache.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts"],"sourcesContent":["import * as React from 'react';\nimport { Client } from '@urql/core';\n\nconst OBJ = {};\n\n/** `urql`'s React Context.\n *\n * @remarks\n * The React Context that `urql`’s {@link Client} will be provided with.\n * You may use the reexported {@link Provider} to provide a `Client` as well.\n */\nexport const Context: import('react').Context<Client | object> =\n  React.createContext(OBJ);\n\n/** Provider for `urql`'s {@link Client} to GraphQL hooks.\n *\n * @remarks\n * `Provider` accepts a {@link Client} and provides it to all GraphQL hooks,\n * and {@link useClient}.\n *\n * You should make sure to create a {@link Client} and provide it with the\n * `Provider` to parts of your component tree that use GraphQL hooks.\n *\n * @example\n * ```tsx\n * import { Provider } from 'urql';\n * // All of `@urql/core` is also re-exported by `urql`:\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n *\n * const client = new Client({\n *   url: 'https://API',\n *   exchanges: [cacheExchange, fetchExchange],\n * });\n *\n * const App = () => (\n *   <Provider value={client}>\n *     <Component />\n *   </Provider>\n * );\n * ```\n */\nexport const Provider: React.Provider<Client | object> = Context.Provider;\n\n/** React Consumer component, providing the {@link Client} provided on a parent component.\n * @remarks\n * This is an alias for {@link Context.Consumer}.\n */\nexport const Consumer: React.Consumer<Client | object> = Context.Consumer;\n\nContext.displayName = 'UrqlContext';\n\n/** Hook returning a {@link Client} from {@link Context}.\n *\n * @remarks\n * `useClient` is a convenience hook, which accesses `urql`'s {@link Context}\n * and returns the {@link Client} defined on it.\n *\n * This will be the {@link Client} you passed to a {@link Provider}\n * you wrapped your elements containing this hook with.\n *\n * @throws\n * In development, if the component you call `useClient()` in is\n * not wrapped in a {@link Provider}, an error is thrown.\n */\nexport const useClient = (): Client => {\n  const client = React.useContext(Context);\n\n  if (client === OBJ && process.env.NODE_ENV !== 'production') {\n    const error =\n      \"No client has been specified using urql's Provider. please create a client and add a Provider.\";\n\n    console.error(error);\n    throw new Error(error);\n  }\n\n  return client as Client;\n};\n","import * as React from 'react';\n\nexport const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\n// Two operations are considered equal if they have the same key\nconst areOperationsEqual = (\n  a: { key: number } | undefined,\n  b: { key: number } | undefined\n) => {\n  return a === b || !!(a && b && a.key === b.key);\n};\n\n/**\n * Checks if two objects are shallowly different with a special case for\n * 'operation' where it compares the key if they are not the otherwise equal\n */\nconst isShallowDifferent = <T extends Record<string, any>>(a: T, b: T) => {\n  for (const key in a) if (!(key in b)) return true;\n  for (const key in b) {\n    if (\n      key === 'operation'\n        ? !areOperationsEqual(a[key], b[key])\n        : a[key] !== b[key]\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\ninterface Stateish {\n  data?: any;\n  error?: any;\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState: T = {\n    ...prevState,\n    ...result,\n    data:\n      result.data !== undefined || result.error ? result.data : prevState.data,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n\nconst reactSharedInternals = (React as any)\n  .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nexport function deferDispatch<Dispatch extends React.Dispatch<any>>(\n  setState: Dispatch,\n  value: Dispatch extends React.Dispatch<infer State> ? State : void\n) {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    !!reactSharedInternals &&\n    !!reactSharedInternals.ReactCurrentOwner &&\n    !!reactSharedInternals.ReactCurrentOwner.current\n  ) {\n    Promise.resolve(value).then(setState);\n  } else {\n    setState(value);\n  }\n}\n","import * as React from 'react';\nimport { pipe, onPush, filter, toPromise, take } from 'wonka';\n\nimport {\n  AnyVariables,\n  DocumentInput,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { deferDispatch, initialState } from './state';\n\n/** State of the last mutation executed by your {@link useMutation} hook.\n *\n * @remarks\n * `UseMutationState` is returned (in a tuple) by {@link useMutation} and\n * gives you the {@link OperationResult} of the last mutation executed\n * with {@link UseMutationExecute}.\n *\n * Even if the mutation document passed to {@link useMutation} changes,\n * the state isn’t reset, so you can keep displaying the previous result.\n */\nexport interface UseMutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useMutation` is currently executing a mutation. */\n  fetching: boolean;\n  /** Indicates that the mutation result is not fresh.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the mutation\n   * is expected.\n   * This is mostly unused for mutations and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed mutation. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed mutation. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the mutation {@link Operation} that has last been executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useMutation} to execute its GraphQL mutation operation.\n *\n * @param variables - variables using which the mutation will be executed.\n * @param context - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n * @returns the {@link OperationResult} of the mutation.\n *\n * @remarks\n * When called, {@link useMutation} will start the GraphQL mutation\n * it currently holds and use the `variables` passed to it.\n *\n * Once the mutation response comes back from the API, its\n * returned promise will resolve to the mutation’s {@link OperationResult}\n * and the {@link UseMutationState} will be updated with the result.\n *\n * @example\n * ```ts\n * const [result, executeMutation] = useMutation(UpdateTodo);\n * const start = async ({ id, title }) => {\n *   const result = await executeMutation({ id, title });\n * };\n */\nexport type UseMutationExecute<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = (\n  variables: Variables,\n  context?: Partial<OperationContext>\n) => Promise<OperationResult<Data, Variables>>;\n\n/** Result tuple returned by the {@link useMutation} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useMutation}’s state, updated\n * as mutations are executed with the second value, which is\n * used to start mutations and is a {@link UseMutationExecute}\n * function.\n */\nexport type UseMutationResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseMutationState<Data, Variables>, UseMutationExecute<Data, Variables>];\n\n/** Hook to create a GraphQL mutation, run by passing variables to the returned execute function.\n *\n * @param query - a GraphQL mutation document which `useMutation` will execute.\n * @returns a {@link UseMutationResponse} tuple of a {@link UseMutationState} result,\n * and an execute function to start the mutation.\n *\n * @remarks\n * `useMutation` allows GraphQL mutations to be defined and keeps its state\n * after the mutation is started with the returned execute function.\n *\n * Given a GraphQL mutation document it returns state to keep track of the\n * mutation state and a {@link UseMutationExecute} function, which accepts\n * variables for the mutation to be executed.\n * Once called, the mutation executes and the state will be updated with\n * the mutation’s result.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#mutations} for `useMutation` docs.\n *\n * @example\n * ```ts\n * import { gql, useMutation } from 'urql';\n *\n * const UpdateTodo = gql`\n *   mutation ($id: ID!, $title: String!) {\n *     updateTodo(id: $id, title: $title) {\n *       id, title\n *     }\n *   }\n * `;\n *\n * const UpdateTodo = () => {\n *   const [result, executeMutation] = useMutation(UpdateTodo);\n *   const start = async ({ id, title }) => {\n *     const result = await executeMutation({ id, title });\n *   };\n *   // ...\n * };\n * ```\n */\nexport function useMutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(query: DocumentInput<Data, Variables>): UseMutationResponse<Data, Variables> {\n  const isMounted = React.useRef(true);\n  const client = useClient();\n\n  const [state, setState] =\n    React.useState<UseMutationState<Data, Variables>>(initialState);\n\n  const executeMutation = React.useCallback(\n    (variables: Variables, context?: Partial<OperationContext>) => {\n      deferDispatch(setState, { ...initialState, fetching: true });\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        onPush(result => {\n          if (isMounted.current) {\n            deferDispatch(setState, {\n              fetching: false,\n              stale: result.stale,\n              data: result.data,\n              error: result.error,\n              extensions: result.extensions,\n              operation: result.operation,\n            });\n          }\n        }),\n        filter(result => !result.hasNext),\n        take(1),\n        toPromise\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  React.useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","import * as React from 'react';\nimport {\n  AnyVariables,\n  DocumentInput,\n  GraphQLRequest,\n  createRequest,\n} from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing\n * @internal\n */\nexport function useRequest<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  query: DocumentInput<Data, Variables>,\n  variables: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = React.useRef<undefined | GraphQLRequest<Data, Variables>>(\n    undefined\n  );\n\n  return React.useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { Source, pipe, subscribe, onEnd, onPush, takeWhile } from 'wonka';\nimport * as React from 'react';\n\nimport {\n  GraphQLRequestParams,\n  AnyVariables,\n  Client,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { getCacheForClient } from './cache';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useQuery} hook.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\nexport type UseQueryArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useQuery({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t execute the query operation, until either it’s set to `false`\n   * or the {@link UseQueryExecute} function is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/react-preact/#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** State of the current query, your {@link useQuery} hook is executing.\n *\n * @remarks\n * `UseQueryState` is returned (in a tuple) by {@link useQuery} and\n * gives you the updating {@link OperationResult} of GraphQL queries.\n *\n * Even when the query and variables passed to {@link useQuery} change,\n * this state preserves the prior state and sets the `fetching` flag to\n * `true`.\n * This allows you to display the previous state, while implementing\n * a separate loading indicator separately.\n */\nexport interface UseQueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useQuery` is waiting for a new result.\n   *\n   * @remarks\n   * When `useQuery` is passed a new query and/or variables, it will\n   * start executing the new query operation and `fetching` is set to\n   * `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the query is actually\n   * fetching, and doesn’t indicate whether a query is being re-executed\n   * in the background. For this, see {@link UseQueryState.stale}.\n   */\n  fetching: boolean;\n  /** Indicates that the state is not fresh and a new result will follow.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the query\n   * is expected and `useQuery` is waiting for it. This may indicate that\n   * a new request is being requested in the background.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed query. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed query. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed query. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the {@link Operation} that is currently being executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useQuery} to execute a new GraphQL query operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useQuery} will re-execute the GraphQL query operation\n * it currently holds, even if {@link UseQueryArgs.pause} is set to `true`.\n *\n * This is useful for executing a paused query or re-executing a query\n * and get a new network result, by passing a new request policy.\n *\n * ```ts\n * const [result, reexecuteQuery] = useQuery({ query });\n *\n * const refresh = () => {\n *   // Re-execute the query with a network-only policy, skipping the cache\n *   reexecuteQuery({ requestPolicy: 'network-only' });\n * };\n * ```\n */\nexport type UseQueryExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useQuery} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useQuery}’s result and state,\n * a {@link UseQueryState} object,\n * and the second is used to imperatively re-execute the query\n * via a {@link UseQueryExecute} function.\n */\nexport type UseQueryResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseQueryState<Data, Variables>, UseQueryExecute];\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\n/** Hook to run a GraphQL query and get updated GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} tuple of a {@link UseQueryState} result, and re-execute function.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the query, and changes when your input `args` change.\n *\n * Additionally, if the `suspense` option is enabled on the `Client`,\n * the `useQuery` hook will suspend instead of indicating that it’s\n * waiting for a result via {@link UseQueryState.fetching}.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from 'urql';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * const Todos = () => {\n *   const [result, reexecuteQuery] = useQuery({\n *     query: TodosQuery,\n *     variables: {},\n *   });\n *   // ...\n * };\n * ```\n */\nexport function useQuery<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(args: UseQueryArgs<Variables, Data>): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const cache = getCacheForClient(client);\n  const suspense = isSuspense(client, args.context);\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const source = React.useMemo(() => {\n    if (args.pause) return null;\n\n    const source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n    });\n\n    return suspense\n      ? pipe(\n          source,\n          onPush(result => {\n            cache.set(request.key, result);\n          })\n        )\n      : source;\n  }, [\n    cache,\n    client,\n    request,\n    suspense,\n    args.pause,\n    args.requestPolicy,\n    args.context,\n  ]);\n\n  const getSnapshot = React.useCallback(\n    (\n      source: Source<OperationResult<Data, Variables>> | null,\n      suspense: boolean\n    ): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) return { fetching: false };\n\n      let result = cache.get(request.key);\n      if (!result) {\n        let resolve: (value: unknown) => void;\n\n        const subscription = pipe(\n          source,\n          takeWhile(() => (suspense && !resolve) || !result),\n          subscribe(_result => {\n            result = _result;\n            if (resolve) resolve(result);\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = new Promise(_resolve => {\n            resolve = _resolve;\n          });\n\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || { fetching: true };\n    },\n    [cache, request]\n  );\n\n  const deps = [\n    client,\n    request,\n    args.requestPolicy,\n    args.context,\n    args.pause,\n  ] as const;\n\n  const [state, setState] = React.useState(\n    () =>\n      [\n        source,\n        computeNextState(initialState, getSnapshot(source, suspense)),\n        deps,\n      ] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(\n        state[1],\n        getSnapshot(source, suspense)\n      )),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const source = state[0];\n    const request = state[2][1];\n\n    let hasResult = false;\n\n    const updateResult = (result: Partial<UseQueryState<Data, Variables>>) => {\n      hasResult = true;\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        return state[1] !== nextResult\n          ? [state[0], nextResult, state[2]]\n          : state;\n      });\n    };\n\n    if (source) {\n      const subscription = pipe(\n        source,\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      );\n\n      if (!hasResult) updateResult({ fetching: true });\n\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [cache, state[0], state[2][1]]);\n\n  const executeQuery = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      deferDispatch(setState, state => {\n        const source = suspense\n          ? pipe(\n              client.executeQuery(request, context),\n              onPush(result => {\n                cache.set(request.key, result);\n              })\n            )\n          : client.executeQuery(request, context);\n        return [source, state[1], deps];\n      });\n    },\n    [\n      client,\n      cache,\n      request,\n      suspense,\n      getSnapshot,\n      args.requestPolicy,\n      args.context,\n    ]\n  );\n\n  return [currentResult, executeQuery];\n}\n","import { pipe, subscribe } from 'wonka';\nimport { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport * as React from 'react';\n\nimport {\n  GraphQLRequestParams,\n  AnyVariables,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useSubscription} hook.\n *\n * @param query - The GraphQL subscription document that `useSubscription` executes.\n * @param variables - The variables for the GraphQL subscription that `useSubscription` executes.\n */\nexport type UseSubscriptionArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  /** Prevents {@link useSubscription} from automatically starting GraphQL subscriptions.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useSubscription} from starting its subscription\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t start the subscription operation, until either it’s set to `false`\n   * or the {@link UseSubscriptionExecute} function is called.\n   */\n  pause?: boolean;\n  /** Updates the {@link OperationContext} for the executed GraphQL subscription operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useSubscription}, to update the {@link OperationContext}\n   * of a subscription operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useSubscription({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** Combines previous data with an incoming subscription result’s data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link useSubscription} to\n * aggregate subscription results into a combined {@link UseSubscriptionState.data}\n * value.\n *\n * This is useful when a subscription event delivers a single item, while\n * you’d like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const [result, executeSubscription] = useSubscription(\n *   { query: NotificationsSubscription },\n *   combineNotifications,\n * );\n * ```\n */\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\n/** State of the current subscription, your {@link useSubscription} hook is executing.\n *\n * @remarks\n * `UseSubscriptionState` is returned (in a tuple) by {@link useSubscription} and\n * gives you the updating {@link OperationResult} of GraphQL subscriptions.\n *\n * If a {@link SubscriptionHandler} has been passed to `useSubscription` then\n * {@link UseSubscriptionState.data} is instead the updated data as returned\n * by the handler, otherwise it’s the latest result’s data.\n *\n * Hint: Even when the query and variables passed to {@link useSubscription} change,\n * this state preserves the prior state.\n */\nexport interface UseSubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useSubscription`’s subscription is active.\n   *\n   * @remarks\n   * When `useSubscription` starts a subscription, the `fetching` flag\n   * is set to `true` and will remain `true` until the subscription\n   * completes on the API, or the {@link UseSubscriptionArgs.pause}\n   * flag is set to `true`.\n   */\n  fetching: boolean;\n  /** Indicates that the subscription result is not fresh.\n   *\n   * @remarks\n   * This is mostly unused for subscriptions and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed subscription, or data returned by a handler.\n   *\n   * @remarks\n   * `data` will be set to the last {@link OperationResult.data} value\n   * received for the subscription.\n   *\n   * It will instead be set to the values that {@link SubscriptionHandler}\n   * returned, if a handler has been passed to {@link useSubscription}.\n   */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed subscription. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the subscription {@link Operation} that is currently active.\n   * When {@link UseSubscriptionState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useSubscription} to reexecute a GraphQL subscription operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseSubscriptionArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useSubscription} will restart the GraphQL subscription\n * operation it currently holds. If {@link UseSubscriptionArgs.pause} is set\n * to `true`, it will start executing the subscription.\n *\n * ```ts\n * const [result, executeSubscription] = useSubscription({\n *   query,\n *   pause: true,\n * });\n *\n * const start = () => {\n *   executeSubscription();\n * };\n * ```\n */\nexport type UseSubscriptionExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useSubscription} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useSubscription}’s state,\n * a {@link UseSubscriptionState} object,\n * and the second is used to imperatively re-execute or start the subscription\n * via a {@link UseMutationExecute} function.\n */\nexport type UseSubscriptionResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseSubscriptionState<Data, Variables>, UseSubscriptionExecute];\n\n/** Hook to run a GraphQL subscription and get updated GraphQL results.\n *\n * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link UseSubscriptionResponse} tuple of a {@link UseSubscriptionState} result, and an execute function.\n *\n * @remarks\n * `useSubscription` allows GraphQL subscriptions to be defined and executed.\n * Given {@link UseSubscriptionArgs.query}, it executes the GraphQL subscription with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the subscription, and `data` is updated with the result’s data\n * or with the `data` that a `handler` returns.\n *\n * @example\n * ```ts\n * import { gql, useSubscription } from 'urql';\n *\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const Notifications = () => {\n *   const [result, executeSubscription] = useSubscription(\n *     { query: NotificationsSubscription },\n *     combineNotifications,\n *   );\n *   // ...\n * };\n * ```\n */\nexport function useSubscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const handlerRef = React.useRef<\n    SubscriptionHandler<Data, Result> | undefined\n  >(handler);\n  handlerRef.current = handler;\n\n  const source = React.useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = React.useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: !!source });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      deferDispatch(setState, state => [source, state[1], deps]);\n    },\n    [client, args.context, request]\n  );\n\n  return [currentResult, executeSubscription];\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables, DocumentInput } from '@urql/core';\n\nimport { useMutation, UseMutationState, UseMutationExecute } from '../hooks';\n\n/** Props accepted by {@link Mutation}.\n *\n * @remarks\n * `MutationProps` are the props accepted by the {@link Mutation} component.\n *\n * The result, the {@link MutationState} object, will be passed to\n * a {@link MutationProps.children} function, passed as children\n * to the `Mutation` component.\n */\nexport interface MutationProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /* The GraphQL mutation document that {@link useMutation} will execute. */\n  query: DocumentInput<Data, Variables>;\n  children(arg: MutationState<Data, Variables>): ReactElement<any>;\n}\n\n/** Object that {@link MutationProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseMutationstate} with an added\n * {@link MutationState.executeMutation} method, which is usually\n * part of a tuple returned by {@link useMutation}.\n */\nexport interface MutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseMutationState<Data, Variables> {\n  /** Alias to {@link useMutation}’s `executeMutation` function. */\n  executeMutation: UseMutationExecute<Data, Variables>;\n}\n\n/** Component Wrapper around {@link useMutation} to run a GraphQL query.\n *\n * @remarks\n * `Mutation` is a component wrapper around the {@link useMutation} hook\n * that calls the {@link MutationProps.children} prop, as a function,\n * with the {@link MutationState} object.\n */\nexport function Mutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: MutationProps<Data, Variables>): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables } from '@urql/core';\n\nimport {\n  useQuery,\n  UseQueryArgs,\n  UseQueryState,\n  UseQueryExecute,\n} from '../hooks';\n\n/** Props accepted by {@link Query}.\n *\n * @remarks\n * `QueryProps` are the props accepted by the {@link Query} component,\n * which is identical to {@link UseQueryArgs}.\n *\n * The result, the {@link QueryState} object, will be passed to\n * a {@link QueryProps.children} function, passed as children\n * to the `Query` component.\n */\nexport type QueryProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = UseQueryArgs<Variables, Data> & {\n  children(arg: QueryState<Data, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link QueryProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseQueryState} with an added\n * {@link QueryState.executeQuery} method, which is usually\n * part of a tuple returned by {@link useQuery}.\n */\nexport interface QueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseQueryState<Data, Variables> {\n  /** Alias to {@link useQuery}’s `executeQuery` function. */\n  executeQuery: UseQueryExecute;\n}\n\n/** Component Wrapper around {@link useQuery} to run a GraphQL query.\n *\n * @remarks\n * `Query` is a component wrapper around the {@link useQuery} hook\n * that calls the {@link QueryProps.children} prop, as a function,\n * with the {@link QueryState} object.\n */\nexport function Query<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: QueryProps<Data, Variables>): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  UseSubscriptionExecute,\n  SubscriptionHandler,\n} from '../hooks';\n\n/** Props accepted by {@link Subscription}.\n *\n * @remarks\n * `SubscriptionProps` are the props accepted by the {@link Subscription} component,\n * which is identical to {@link UseSubscriptionArgs} with an added\n * {@link SubscriptionProps.handler} prop, which {@link useSubscription} usually\n * accepts as an additional argument.\n *\n * The result, the {@link SubscriptionState} object, will be passed to\n * a {@link SubscriptionProps.children} function, passed as children\n * to the `Subscription` component.\n */\nexport type SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n> = UseSubscriptionArgs<Variables, Data> & {\n  handler?: SubscriptionHandler<Data, Result>;\n  children(arg: SubscriptionState<Result, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link SubscriptionProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseSubscriptionState} with an added\n * {@link SubscriptionState.executeSubscription} method, which is usually\n * part of a tuple returned by {@link useSubscription}.\n */\nexport interface SubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseSubscriptionState<Data, Variables> {\n  /** Alias to {@link useSubscription}’s `executeMutation` function. */\n  executeSubscription: UseSubscriptionExecute;\n}\n\n/** Component Wrapper around {@link useSubscription} to run a GraphQL subscription.\n *\n * @remarks\n * `Subscription` is a component wrapper around the {@link useSubscription} hook\n * that calls the {@link SubscriptionProps.children} prop, as a function,\n * with the {@link SubscriptionState} object.\n */\nexport function Subscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(props: SubscriptionProps<Data, Result, Variables>): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"],"names":["Context","React","createContext","Provider","Consumer","displayName","useClient","useContext","initialState","fetching","stale","error","undefined","data","extensions","operation","areOperationsEqual","a","b","key","computeNextState","prevState","result","newState","isShallowDifferent","hasDepsChanged","i","l","length","deferDispatch","setState","value","useMutation","query","isMounted","useRef","client","state","useState","executeMutation","useCallback","variables","context","toPromise","take","filter","hasNext","onPush","current","createRequest","useEffect","useRequest","prev","useMemo","request","useQuery","args","cache","_react","reclaim","Set","map","Map","operations$","subscribe","kind","has","delete","get","set","dispose","add","getCacheForClient","suspense","isSuspense","source","pause","executeQuery","requestPolicy","getSnapshot","resolve","subscription","_result","takeWhile","promise","Promise","_resolve","unsubscribe","deps","currentResult","hasResult","updateResult","nextResult","onEnd","opts","useSubscription","handler","handlerRef","executeSubscription","props","mutation","children"],"mappings":"yHAWaA,EACXC,EAAMC,cATI,CAAA,GAsCCC,EAA4CH,EAAQG,SAMpDC,EAA4CJ,EAAQI,SAEjEJ,EAAQK,YAAc,cAeTC,IAAAA,EAAYA,IACRL,EAAMM,WAAWP,GC/DrBQ,EAAe,CAC1BC,UAAU,EACVC,OAAO,EACPC,WAAOC,EACPC,UAAMD,EACNE,gBAAYF,EACZG,eAAWH,GAIPI,EAAqBA,CACzBC,EACAC,IAEOD,IAAMC,MAAQD,IAAKC,GAAKD,EAAEE,MAAQD,EAAEC,KA4BhCC,EAAmBA,CAC9BC,EACAC,KAEA,IAAMC,EAAc,IACfF,KACAC,EACHT,UACkBD,IAAhBU,EAAOT,MAAsBS,EAAOX,MAAQW,EAAOT,KAAOQ,EAAUR,KACtEJ,WAAYa,EAAOb,SACnBC,QAASY,EAAOZ,OAGlB,MAlCyBc,EAAgCP,EAAMC,KAC/D,IAAK,IAAMC,KAAOF,EAAG,KAAME,KAAOD,GAAI,OAAO,EAC7C,IAAK,IAAMC,KAAOD,EAChB,GACU,cAARC,GACKH,EAAmBC,EAAEE,GAAMD,EAAEC,IAC9BF,EAAEE,KAASD,EAAEC,GAEjB,OAAO,EAGX,OAAO,CAAK,EAuBLK,CAAmBH,EAAWE,GAAYA,EAAWF,CAAS,EAG1DI,EAAiBA,CAA+BR,EAAMC,KACjE,IAAK,IAAIQ,EAAI,EAAGC,EAAIT,EAAEU,OAAQF,EAAIC,EAAGD,IAAK,GAAIT,EAAES,KAAOR,EAAEQ,GAAI,OAAO,EACpE,OAAO,CAAK,EAMP,SAASG,EACdC,EACAC,GAUED,EAASC,EAEb,CC4DO,SAASC,EAGdC,GACA,IAAMC,EAAYjC,EAAMkC,QAAO,GACzBC,EAAS9B,KAER+B,EAAOP,GACZ7B,EAAMqC,SAA4C9B,GAE9C+B,EAAkBtC,EAAMuC,aAC5B,CAACC,EAAsBC,KACrBb,EAAcC,EAAU,IAAKtB,EAAcC,UAAU,IAoBnDkC,YADAC,EAAAA,KAAK,EAALA,CADAC,EAAMA,QAACvB,IAAWA,EAAOwB,SAAzBD,CAZAE,EAAAA,QAAOzB,IACDY,EAAUc,SACZnB,EAAcC,EAAU,CACtBrB,UAAU,EACVC,MAAOY,EAAOZ,MACdG,KAAMS,EAAOT,KACbF,MAAOW,EAAOX,MACdG,WAAYQ,EAAOR,WACnBC,UAAWO,EAAOP,WAEtB,GAVFgC,CAJAX,EAAOG,gBACLU,EAAAA,cAA+BhB,EAAOQ,GACtCC,GAAW,CAAA,SAoBjB,CAACN,EAAQH,EAAOH,IAUlB,OAPA7B,EAAMiD,WAAU,KACdhB,EAAUc,SAAU,EACb,KACLd,EAAUc,SAAU,CAAK,IAE1B,IAEI,CAACX,EAAOE,EACjB,CClLO,SAASY,EAIdlB,EACAQ,GAEA,IAAMW,EAAOnD,EAAMkC,YACjBvB,GAGF,OAAOX,EAAMoD,SAAQ,KACnB,IAAMC,EAAUL,EAAAA,cAA+BhB,EAAOQ,GAEtD,YAAqB7B,IAAjBwC,EAAKJ,SAAyBI,EAAKJ,QAAQ7B,MAAQmC,EAAQnC,IACtDiC,EAAKJ,SAEZI,EAAKJ,QAAUM,EACRA,EACT,GACC,CAACrB,EAAOQ,GACb,CCsLO,SAASc,EAGdC,GACA,IAAMpB,EAAS9B,IACTmD,EC5M0BrB,KAChC,IAAMA,EAA2BsB,OAAQ,CACvC,IAAMC,EAAU,IAAIC,IACdC,EAAM,IAAIC,IAEZ1B,EAAO2B,aAGPC,EAAAA,WAAUjD,IACe,aAAnBA,EAAUkD,MAAuBN,EAAQO,IAAInD,EAAUI,OACzDwC,EAAQQ,OAAOpD,EAAUI,KACzB0C,EAAIM,OAAOpD,EAAUI,KACvB,GAJF6C,CADA5B,EAAO2B,aAUV3B,EAA2BsB,OAAS,CACnCU,IAAIjD,GACK0C,EAAIO,IAAIjD,GAEjBkD,IAAIlD,EAAKY,GACP4B,EAAQQ,OAAOhD,GACf0C,EAAIQ,IAAIlD,EAAKY,EACd,EACDuC,QAAQnD,GACNwC,EAAQY,IAAIpD,EACd,EAEJ,CAEA,OAAQiB,EAA2BsB,MAAM,ED6K3Bc,CAAkBpC,GAC1BqC,EA7CWC,EAACtC,EAAgBM,IAClCN,EAAOqC,YAAc/B,IAAgC,IAArBA,EAAQ+B,UA4CvBC,CAAWtC,EAAQoB,EAAKd,SACnCY,EAAUH,EAAWK,EAAKvB,MAAOuB,EAAKf,WAEtCkC,EAAS1E,EAAMoD,SAAQ,KAC3B,GAAIG,EAAKoB,MAAO,OAAO,KAEvB,IAAMD,EAASvC,EAAOyC,aAAavB,EAAS,CAC1CwB,cAAetB,EAAKsB,iBACjBtB,EAAKd,UAGV,OAAO+B,EAGD1B,EAAMA,QAACzB,IACLmC,EAAMY,IAAIf,EAAQnC,IAAKG,EAAO,GADhCyB,CADA4B,GAKFA,CAAM,GACT,CACDlB,EACArB,EACAkB,EACAmB,EACAjB,EAAKoB,MACLpB,EAAKsB,cACLtB,EAAKd,UAGDqC,EAAc9E,EAAMuC,aACxB,CACEmC,EACAF,KAEA,IAAKE,EAAQ,MAAO,CAAElE,UAAU,GAEhC,IAAIa,EAASmC,EAAMW,IAAId,EAAQnC,KAC/B,GAAKG,GAsBE,GAAImD,GAAsB,MAAVnD,GAAkB,SAAUA,EACjD,MAAMA,MAvBK,CACX,IAAI0D,EAEEC,EAGJjB,EAASA,WAACkB,IACR5D,EAAS4D,EACLF,GAASA,EAAQ1D,EAAO,GAF9B0C,CADAmB,EAAAA,WAAU,IAAOV,IAAaO,IAAa1D,GAA3C6D,CADAR,IAQF,GAAc,MAAVrD,GAAkBmD,EAAU,CAC9B,IAAMW,EAAU,IAAIC,SAAQC,IAC1BN,EAAUM,CAAQ,IAIpB,MADA7B,EAAMY,IAAIf,EAAQnC,IAAKiE,GACjBA,CACR,CACEH,EAAaM,aAEhB,CAID,OAAQjE,GAA+C,CAAEb,UAAU,EAAM,GAE3E,CAACgD,EAAOH,IAGJkC,EAAO,CACXpD,EACAkB,EACAE,EAAKsB,cACLtB,EAAKd,QACLc,EAAKoB,QAGAvC,EAAOP,GAAY7B,EAAMqC,UAC9B,IACE,CACEqC,EACAvD,EAAiBZ,EAAcuE,EAAYJ,EAAQF,IACnDe,KAIFC,EAAgBpD,EAAM,GACtBsC,IAAWtC,EAAM,IAAMZ,EAAeY,EAAM,GAAImD,IAClD1D,EAAS,CACP6C,EACCc,EAAgBrE,EACfiB,EAAM,GACN0C,EAAYJ,EAAQF,IAEtBe,IAIJvF,EAAMiD,WAAU,KACd,IAAMyB,EAAStC,EAAM,GACfiB,EAAUjB,EAAM,GAAG,GAErBqD,GAAY,EAEVC,EAAgBrE,IACpBoE,GAAY,EACZ7D,EAAcC,GAAUO,IACtB,IAAMuD,EAAaxE,EAAiBiB,EAAM,GAAIf,GAC9C,OAAOe,EAAM,KAAOuD,EAChB,CAACvD,EAAM,GAAIuD,EAAYvD,EAAM,IAC7BA,CAAK,GACT,EAGJ,GAAIsC,EAAQ,CACV,IAAMM,EAKJjB,EAASA,UAAC2B,EAAV3B,CAHA6B,EAAKA,OAAC,KACJF,EAAa,CAAElF,UAAU,GAAQ,GADnCoF,CADAlB,IASF,OAFKe,GAAWC,EAAa,CAAElF,UAAU,IAElC,KACLgD,EAAMa,QAAQhB,EAAQnC,KACtB8D,EAAaM,aAAa,CAE9B,CACEI,EAAa,CAAElF,UAAU,GAC3B,GACC,CAACgD,EAAOpB,EAAM,GAAIA,EAAM,GAAG,KAE9B,IAAMwC,EAAe5E,EAAMuC,aACxBsD,IACC,IAAMpD,EAAU,CACdoC,cAAetB,EAAKsB,iBACjBtB,EAAKd,WACLoD,GAGLjE,EAAcC,GAAUO,GASf,CARQoC,EAGT1B,EAAMA,QAACzB,IACLmC,EAAMY,IAAIf,EAAQnC,IAAKG,EAAO,GADhCyB,CADAX,EAAOyC,aAAavB,EAASZ,IAK/BN,EAAOyC,aAAavB,EAASZ,GACjBL,EAAM,GAAImD,IAC1B,GAEJ,CACEpD,EACAqB,EACAH,EACAmB,EACAM,EACAvB,EAAKsB,cACLtB,EAAKd,UAIT,MAAO,CAAC+C,EAAeZ,EACzB,CEjKO,SAASkB,EAKdvC,EACAwC,GAEA,IAAM5D,EAAS9B,IACTgD,EAAUH,EAAWK,EAAKvB,MAAOuB,EAAKf,WAEtCwD,EAAahG,EAAMkC,OAEvB6D,GACFC,EAAWjD,QAAUgD,EAErB,IAAMrB,EAAS1E,EAAMoD,SACnB,IACGG,EAAKoB,MAA4D,KAApDxC,EAAO8D,oBAAoB5C,EAASE,EAAKd,UACzD,CAACN,EAAQkB,EAASE,EAAKoB,MAAOpB,EAAKd,UAG/B8C,EAAO,CAACpD,EAAQkB,EAASE,EAAKd,QAASc,EAAKoB,QAE3CvC,EAAOP,GAAY7B,EAAMqC,UAC9B,IAAM,CAACqC,EAAQ,IAAKnE,EAAcC,WAAYkE,GAAUa,KAGtDC,EAAgBpD,EAAM,GACtBsC,IAAWtC,EAAM,IAAMZ,EAAeY,EAAM,GAAImD,IAClD1D,EAAS,CACP6C,EACCc,EAAgBrE,EAAiBiB,EAAM,GAAI,CAAE5B,WAAYkE,IAC1Da,IAIJvF,EAAMiD,WAAU,KACd,IAAMyC,EACJrE,IAEAO,EAAcC,GAAUO,IACtB,IAAMuD,EAAaxE,EAAiBiB,EAAM,GAAIf,GAC9C,OAAIe,EAAM,KAAOuD,EAAmBvD,GAChC4D,EAAWjD,SAAWX,EAAM,GAAGxB,OAAS+E,EAAW/E,OACrD+E,EAAW/E,KAAOoF,EAAWjD,QAC3BX,EAAM,GAAGxB,KACT+E,EAAW/E,OAIR,CAACwB,EAAM,GAAIuD,EAAmBvD,EAAM,IAAG,GAC9C,EAGJ,GAAIA,EAAM,GACR,OAKE2B,YAAU2B,EAAV3B,CAHA6B,EAAAA,OAAM,KACJF,EAAa,CAAElF,WAAYkE,GAAS,GADtCkB,CADAxD,EAAM,KAKNkD,YAEFI,EAAa,CAAElF,UAAU,GAC3B,GACC,CAAC4B,EAAM,KAGV,IAAM6D,EAAsBjG,EAAMuC,aAC/BsD,IACC,IAAMnB,EAASvC,EAAO8D,oBAAoB5C,EAAS,IAC9CE,EAAKd,WACLoD,IAGLjE,EAAcC,GAAUO,GAAS,CAACsC,EAAQtC,EAAM,GAAImD,IAAM,GAE5D,CAACpD,EAAQoB,EAAKd,QAASY,IAGzB,MAAO,CAACmC,EAAeS,EACzB,uDCrQO,SAGLC,GACA,IAAMC,EAAWpE,EAA6BmE,EAAMlE,OACpD,OAAOkE,EAAME,SAAS,IAAKD,EAAS,GAAI7D,gBAAiB6D,EAAS,IACpE,mCCFO,SAGLD,GACA,IAAMlE,EAAQsB,EAA0B4C,GACxC,OAAOA,EAAME,SAAS,IAAKpE,EAAM,GAAI4C,aAAc5C,EAAM,IAC3D,uBCDO,SAILkE,GACA,IAAMlB,EAAec,EACnBI,EACAA,EAAMH,SAGR,OAAOG,EAAME,SAAS,IACjBpB,EAAa,GAChBiB,oBAAqBjB,EAAa,IAEtC"}