{"version":3,"file":"urql.es.js","sources":["../src/context.ts","../src/hooks/state.ts","../src/hooks/useMutation.ts","../src/hooks/useRequest.ts","../src/hooks/cache.ts","../src/hooks/useQuery.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts"],"sourcesContent":["import * as React from 'react';\nimport { Client } from '@urql/core';\n\nconst OBJ = {};\n\n/** `urql`'s React Context.\n *\n * @remarks\n * The React Context that `urql`’s {@link Client} will be provided with.\n * You may use the reexported {@link Provider} to provide a `Client` as well.\n */\nexport const Context: import('react').Context<Client | object> =\n  React.createContext(OBJ);\n\n/** Provider for `urql`'s {@link Client} to GraphQL hooks.\n *\n * @remarks\n * `Provider` accepts a {@link Client} and provides it to all GraphQL hooks,\n * and {@link useClient}.\n *\n * You should make sure to create a {@link Client} and provide it with the\n * `Provider` to parts of your component tree that use GraphQL hooks.\n *\n * @example\n * ```tsx\n * import { Provider } from 'urql';\n * // All of `@urql/core` is also re-exported by `urql`:\n * import { Client, cacheExchange, fetchExchange } from '@urql/core';\n *\n * const client = new Client({\n *   url: 'https://API',\n *   exchanges: [cacheExchange, fetchExchange],\n * });\n *\n * const App = () => (\n *   <Provider value={client}>\n *     <Component />\n *   </Provider>\n * );\n * ```\n */\nexport const Provider: React.Provider<Client | object> = Context.Provider;\n\n/** React Consumer component, providing the {@link Client} provided on a parent component.\n * @remarks\n * This is an alias for {@link Context.Consumer}.\n */\nexport const Consumer: React.Consumer<Client | object> = Context.Consumer;\n\nContext.displayName = 'UrqlContext';\n\n/** Hook returning a {@link Client} from {@link Context}.\n *\n * @remarks\n * `useClient` is a convenience hook, which accesses `urql`'s {@link Context}\n * and returns the {@link Client} defined on it.\n *\n * This will be the {@link Client} you passed to a {@link Provider}\n * you wrapped your elements containing this hook with.\n *\n * @throws\n * In development, if the component you call `useClient()` in is\n * not wrapped in a {@link Provider}, an error is thrown.\n */\nexport const useClient = (): Client => {\n  const client = React.useContext(Context);\n\n  if (client === OBJ && process.env.NODE_ENV !== 'production') {\n    const error =\n      \"No client has been specified using urql's Provider. please create a client and add a Provider.\";\n\n    console.error(error);\n    throw new Error(error);\n  }\n\n  return client as Client;\n};\n","import * as React from 'react';\n\nexport const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\n// Two operations are considered equal if they have the same key\nconst areOperationsEqual = (\n  a: { key: number } | undefined,\n  b: { key: number } | undefined\n) => {\n  return a === b || !!(a && b && a.key === b.key);\n};\n\n/**\n * Checks if two objects are shallowly different with a special case for\n * 'operation' where it compares the key if they are not the otherwise equal\n */\nconst isShallowDifferent = <T extends Record<string, any>>(a: T, b: T) => {\n  for (const key in a) if (!(key in b)) return true;\n  for (const key in b) {\n    if (\n      key === 'operation'\n        ? !areOperationsEqual(a[key], b[key])\n        : a[key] !== b[key]\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\ninterface Stateish {\n  data?: any;\n  error?: any;\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState: T = {\n    ...prevState,\n    ...result,\n    data:\n      result.data !== undefined || result.error ? result.data : prevState.data,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n\nconst reactSharedInternals = (React as any)\n  .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nexport function deferDispatch<Dispatch extends React.Dispatch<any>>(\n  setState: Dispatch,\n  value: Dispatch extends React.Dispatch<infer State> ? State : void\n) {\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    !!reactSharedInternals &&\n    !!reactSharedInternals.ReactCurrentOwner &&\n    !!reactSharedInternals.ReactCurrentOwner.current\n  ) {\n    Promise.resolve(value).then(setState);\n  } else {\n    setState(value);\n  }\n}\n","import * as React from 'react';\nimport { pipe, onPush, filter, toPromise, take } from 'wonka';\n\nimport {\n  AnyVariables,\n  DocumentInput,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { deferDispatch, initialState } from './state';\n\n/** State of the last mutation executed by your {@link useMutation} hook.\n *\n * @remarks\n * `UseMutationState` is returned (in a tuple) by {@link useMutation} and\n * gives you the {@link OperationResult} of the last mutation executed\n * with {@link UseMutationExecute}.\n *\n * Even if the mutation document passed to {@link useMutation} changes,\n * the state isn’t reset, so you can keep displaying the previous result.\n */\nexport interface UseMutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useMutation` is currently executing a mutation. */\n  fetching: boolean;\n  /** Indicates that the mutation result is not fresh.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the mutation\n   * is expected.\n   * This is mostly unused for mutations and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed mutation. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed mutation. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the mutation {@link Operation} that has last been executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useMutation} to execute its GraphQL mutation operation.\n *\n * @param variables - variables using which the mutation will be executed.\n * @param context - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n * @returns the {@link OperationResult} of the mutation.\n *\n * @remarks\n * When called, {@link useMutation} will start the GraphQL mutation\n * it currently holds and use the `variables` passed to it.\n *\n * Once the mutation response comes back from the API, its\n * returned promise will resolve to the mutation’s {@link OperationResult}\n * and the {@link UseMutationState} will be updated with the result.\n *\n * @example\n * ```ts\n * const [result, executeMutation] = useMutation(UpdateTodo);\n * const start = async ({ id, title }) => {\n *   const result = await executeMutation({ id, title });\n * };\n */\nexport type UseMutationExecute<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = (\n  variables: Variables,\n  context?: Partial<OperationContext>\n) => Promise<OperationResult<Data, Variables>>;\n\n/** Result tuple returned by the {@link useMutation} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useMutation}’s state, updated\n * as mutations are executed with the second value, which is\n * used to start mutations and is a {@link UseMutationExecute}\n * function.\n */\nexport type UseMutationResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseMutationState<Data, Variables>, UseMutationExecute<Data, Variables>];\n\n/** Hook to create a GraphQL mutation, run by passing variables to the returned execute function.\n *\n * @param query - a GraphQL mutation document which `useMutation` will execute.\n * @returns a {@link UseMutationResponse} tuple of a {@link UseMutationState} result,\n * and an execute function to start the mutation.\n *\n * @remarks\n * `useMutation` allows GraphQL mutations to be defined and keeps its state\n * after the mutation is started with the returned execute function.\n *\n * Given a GraphQL mutation document it returns state to keep track of the\n * mutation state and a {@link UseMutationExecute} function, which accepts\n * variables for the mutation to be executed.\n * Once called, the mutation executes and the state will be updated with\n * the mutation’s result.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#mutations} for `useMutation` docs.\n *\n * @example\n * ```ts\n * import { gql, useMutation } from 'urql';\n *\n * const UpdateTodo = gql`\n *   mutation ($id: ID!, $title: String!) {\n *     updateTodo(id: $id, title: $title) {\n *       id, title\n *     }\n *   }\n * `;\n *\n * const UpdateTodo = () => {\n *   const [result, executeMutation] = useMutation(UpdateTodo);\n *   const start = async ({ id, title }) => {\n *     const result = await executeMutation({ id, title });\n *   };\n *   // ...\n * };\n * ```\n */\nexport function useMutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(query: DocumentInput<Data, Variables>): UseMutationResponse<Data, Variables> {\n  const isMounted = React.useRef(true);\n  const client = useClient();\n\n  const [state, setState] =\n    React.useState<UseMutationState<Data, Variables>>(initialState);\n\n  const executeMutation = React.useCallback(\n    (variables: Variables, context?: Partial<OperationContext>) => {\n      deferDispatch(setState, { ...initialState, fetching: true });\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        onPush(result => {\n          if (isMounted.current) {\n            deferDispatch(setState, {\n              fetching: false,\n              stale: result.stale,\n              data: result.data,\n              error: result.error,\n              extensions: result.extensions,\n              operation: result.operation,\n            });\n          }\n        }),\n        filter(result => !result.hasNext),\n        take(1),\n        toPromise\n      );\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  React.useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","import * as React from 'react';\nimport {\n  AnyVariables,\n  DocumentInput,\n  GraphQLRequest,\n  createRequest,\n} from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing\n * @internal\n */\nexport function useRequest<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(\n  query: DocumentInput<Data, Variables>,\n  variables: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = React.useRef<undefined | GraphQLRequest<Data, Variables>>(\n    undefined\n  );\n\n  return React.useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","import { pipe, subscribe } from 'wonka';\nimport { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { Source, pipe, subscribe, onEnd, onPush, takeWhile } from 'wonka';\nimport * as React from 'react';\n\nimport {\n  GraphQLRequestParams,\n  AnyVariables,\n  Client,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { getCacheForClient } from './cache';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useQuery} hook.\n *\n * @param query - The GraphQL query that `useQuery` executes.\n * @param variables - The variables for the GraphQL query that `useQuery` executes.\n */\nexport type UseQueryArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  /** Updates the {@link RequestPolicy} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `requestPolicy` modifies the {@link RequestPolicy} of the GraphQL query operation\n   * that `useQuery` executes, and indicates a caching strategy for cache exchanges.\n   *\n   * For example, when set to `'cache-and-network'`, {@link useQuery} will\n   * receive a cached result with `stale: true` and an API request will be\n   * sent in the background.\n   *\n   * @see {@link OperationContext.requestPolicy} for where this value is set.\n   */\n  requestPolicy?: RequestPolicy;\n  /** Updates the {@link OperationContext} for the executed GraphQL query operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useQuery}, to update the {@link OperationContext}\n   * of a query operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useQuery({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n  /** Prevents {@link useQuery} from automatically executing GraphQL query operations.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useQuery} from executing\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t execute the query operation, until either it’s set to `false`\n   * or the {@link UseQueryExecute} function is called.\n   *\n   * @see {@link https://urql.dev/goto/docs/basics/react-preact/#pausing-usequery} for\n   * documentation on the `pause` option.\n   */\n  pause?: boolean;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** State of the current query, your {@link useQuery} hook is executing.\n *\n * @remarks\n * `UseQueryState` is returned (in a tuple) by {@link useQuery} and\n * gives you the updating {@link OperationResult} of GraphQL queries.\n *\n * Even when the query and variables passed to {@link useQuery} change,\n * this state preserves the prior state and sets the `fetching` flag to\n * `true`.\n * This allows you to display the previous state, while implementing\n * a separate loading indicator separately.\n */\nexport interface UseQueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useQuery` is waiting for a new result.\n   *\n   * @remarks\n   * When `useQuery` is passed a new query and/or variables, it will\n   * start executing the new query operation and `fetching` is set to\n   * `true` until a result arrives.\n   *\n   * Hint: This is subtly different than whether the query is actually\n   * fetching, and doesn’t indicate whether a query is being re-executed\n   * in the background. For this, see {@link UseQueryState.stale}.\n   */\n  fetching: boolean;\n  /** Indicates that the state is not fresh and a new result will follow.\n   *\n   * @remarks\n   * The `stale` flag is set to `true` when a new result for the query\n   * is expected and `useQuery` is waiting for it. This may indicate that\n   * a new request is being requested in the background.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed query. */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed query. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed query. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the {@link Operation} that is currently being executed.\n   * When {@link UseQueryState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useQuery} to execute a new GraphQL query operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseQueryArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useQuery} will re-execute the GraphQL query operation\n * it currently holds, even if {@link UseQueryArgs.pause} is set to `true`.\n *\n * This is useful for executing a paused query or re-executing a query\n * and get a new network result, by passing a new request policy.\n *\n * ```ts\n * const [result, reexecuteQuery] = useQuery({ query });\n *\n * const refresh = () => {\n *   // Re-execute the query with a network-only policy, skipping the cache\n *   reexecuteQuery({ requestPolicy: 'network-only' });\n * };\n * ```\n */\nexport type UseQueryExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useQuery} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useQuery}’s result and state,\n * a {@link UseQueryState} object,\n * and the second is used to imperatively re-execute the query\n * via a {@link UseQueryExecute} function.\n */\nexport type UseQueryResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseQueryState<Data, Variables>, UseQueryExecute];\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\n/** Hook to run a GraphQL query and get updated GraphQL results.\n *\n * @param args - a {@link UseQueryArgs} object, to pass a `query`, `variables`, and options.\n * @returns a {@link UseQueryResponse} tuple of a {@link UseQueryState} result, and re-execute function.\n *\n * @remarks\n * `useQuery` allows GraphQL queries to be defined and executed.\n * Given {@link UseQueryArgs.query}, it executes the GraphQL query with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the query, and changes when your input `args` change.\n *\n * Additionally, if the `suspense` option is enabled on the `Client`,\n * the `useQuery` hook will suspend instead of indicating that it’s\n * waiting for a result via {@link UseQueryState.fetching}.\n *\n * @see {@link https://urql.dev/goto/urql/docs/basics/react-preact/#queries} for `useQuery` docs.\n *\n * @example\n * ```ts\n * import { gql, useQuery } from 'urql';\n *\n * const TodosQuery = gql`\n *   query { todos { id, title } }\n * `;\n *\n * const Todos = () => {\n *   const [result, reexecuteQuery] = useQuery({\n *     query: TodosQuery,\n *     variables: {},\n *   });\n *   // ...\n * };\n * ```\n */\nexport function useQuery<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(args: UseQueryArgs<Variables, Data>): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const cache = getCacheForClient(client);\n  const suspense = isSuspense(client, args.context);\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const source = React.useMemo(() => {\n    if (args.pause) return null;\n\n    const source = client.executeQuery(request, {\n      requestPolicy: args.requestPolicy,\n      ...args.context,\n    });\n\n    return suspense\n      ? pipe(\n          source,\n          onPush(result => {\n            cache.set(request.key, result);\n          })\n        )\n      : source;\n  }, [\n    cache,\n    client,\n    request,\n    suspense,\n    args.pause,\n    args.requestPolicy,\n    args.context,\n  ]);\n\n  const getSnapshot = React.useCallback(\n    (\n      source: Source<OperationResult<Data, Variables>> | null,\n      suspense: boolean\n    ): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) return { fetching: false };\n\n      let result = cache.get(request.key);\n      if (!result) {\n        let resolve: (value: unknown) => void;\n\n        const subscription = pipe(\n          source,\n          takeWhile(() => (suspense && !resolve) || !result),\n          subscribe(_result => {\n            result = _result;\n            if (resolve) resolve(result);\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = new Promise(_resolve => {\n            resolve = _resolve;\n          });\n\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || { fetching: true };\n    },\n    [cache, request]\n  );\n\n  const deps = [\n    client,\n    request,\n    args.requestPolicy,\n    args.context,\n    args.pause,\n  ] as const;\n\n  const [state, setState] = React.useState(\n    () =>\n      [\n        source,\n        computeNextState(initialState, getSnapshot(source, suspense)),\n        deps,\n      ] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(\n        state[1],\n        getSnapshot(source, suspense)\n      )),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const source = state[0];\n    const request = state[2][1];\n\n    let hasResult = false;\n\n    const updateResult = (result: Partial<UseQueryState<Data, Variables>>) => {\n      hasResult = true;\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        return state[1] !== nextResult\n          ? [state[0], nextResult, state[2]]\n          : state;\n      });\n    };\n\n    if (source) {\n      const subscription = pipe(\n        source,\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      );\n\n      if (!hasResult) updateResult({ fetching: true });\n\n      return () => {\n        cache.dispose(request.key);\n        subscription.unsubscribe();\n      };\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [cache, state[0], state[2][1]]);\n\n  const executeQuery = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      deferDispatch(setState, state => {\n        const source = suspense\n          ? pipe(\n              client.executeQuery(request, context),\n              onPush(result => {\n                cache.set(request.key, result);\n              })\n            )\n          : client.executeQuery(request, context);\n        return [source, state[1], deps];\n      });\n    },\n    [\n      client,\n      cache,\n      request,\n      suspense,\n      getSnapshot,\n      args.requestPolicy,\n      args.context,\n    ]\n  );\n\n  return [currentResult, executeQuery];\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport * as React from 'react';\n\nimport {\n  GraphQLRequestParams,\n  AnyVariables,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\n\nimport {\n  deferDispatch,\n  initialState,\n  computeNextState,\n  hasDepsChanged,\n} from './state';\n\n/** Input arguments for the {@link useSubscription} hook.\n *\n * @param query - The GraphQL subscription document that `useSubscription` executes.\n * @param variables - The variables for the GraphQL subscription that `useSubscription` executes.\n */\nexport type UseSubscriptionArgs<\n  Variables extends AnyVariables = AnyVariables,\n  Data = any\n> = {\n  /** Prevents {@link useSubscription} from automatically starting GraphQL subscriptions.\n   *\n   * @remarks\n   * `pause` may be set to `true` to stop {@link useSubscription} from starting its subscription\n   * automatically. The hook will stop receiving updates from the {@link Client}\n   * and won’t start the subscription operation, until either it’s set to `false`\n   * or the {@link UseSubscriptionExecute} function is called.\n   */\n  pause?: boolean;\n  /** Updates the {@link OperationContext} for the executed GraphQL subscription operation.\n   *\n   * @remarks\n   * `context` may be passed to {@link useSubscription}, to update the {@link OperationContext}\n   * of a subscription operation. This may be used to update the `context` that exchanges\n   * will receive for a single hook.\n   *\n   * Hint: This should be wrapped in a `useMemo` hook, to make sure that your\n   * component doesn’t infinitely update.\n   *\n   * @example\n   * ```ts\n   * const [result, reexecute] = useSubscription({\n   *   query,\n   *   context: useMemo(() => ({\n   *     additionalTypenames: ['Item'],\n   *   }), [])\n   * });\n   * ```\n   */\n  context?: Partial<OperationContext>;\n} & GraphQLRequestParams<Data, Variables>;\n\n/** Combines previous data with an incoming subscription result’s data.\n *\n * @remarks\n * A `SubscriptionHandler` may be passed to {@link useSubscription} to\n * aggregate subscription results into a combined {@link UseSubscriptionState.data}\n * value.\n *\n * This is useful when a subscription event delivers a single item, while\n * you’d like to display a list of events.\n *\n * @example\n * ```ts\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const [result, executeSubscription] = useSubscription(\n *   { query: NotificationsSubscription },\n *   combineNotifications,\n * );\n * ```\n */\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\n/** State of the current subscription, your {@link useSubscription} hook is executing.\n *\n * @remarks\n * `UseSubscriptionState` is returned (in a tuple) by {@link useSubscription} and\n * gives you the updating {@link OperationResult} of GraphQL subscriptions.\n *\n * If a {@link SubscriptionHandler} has been passed to `useSubscription` then\n * {@link UseSubscriptionState.data} is instead the updated data as returned\n * by the handler, otherwise it’s the latest result’s data.\n *\n * Hint: Even when the query and variables passed to {@link useSubscription} change,\n * this state preserves the prior state.\n */\nexport interface UseSubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /** Indicates whether `useSubscription`’s subscription is active.\n   *\n   * @remarks\n   * When `useSubscription` starts a subscription, the `fetching` flag\n   * is set to `true` and will remain `true` until the subscription\n   * completes on the API, or the {@link UseSubscriptionArgs.pause}\n   * flag is set to `true`.\n   */\n  fetching: boolean;\n  /** Indicates that the subscription result is not fresh.\n   *\n   * @remarks\n   * This is mostly unused for subscriptions and will rarely affect you, and\n   * is more relevant for queries.\n   *\n   * @see {@link OperationResult.stale} for the source of this value.\n   */\n  stale: boolean;\n  /** The {@link OperationResult.data} for the executed subscription, or data returned by a handler.\n   *\n   * @remarks\n   * `data` will be set to the last {@link OperationResult.data} value\n   * received for the subscription.\n   *\n   * It will instead be set to the values that {@link SubscriptionHandler}\n   * returned, if a handler has been passed to {@link useSubscription}.\n   */\n  data?: Data;\n  /** The {@link OperationResult.error} for the executed subscription. */\n  error?: CombinedError;\n  /** The {@link OperationResult.extensions} for the executed mutation. */\n  extensions?: Record<string, any>;\n  /** The {@link Operation} that the current state is for.\n   *\n   * @remarks\n   * This is the subscription {@link Operation} that is currently active.\n   * When {@link UseSubscriptionState.fetching} is `true`, this is the\n   * last `Operation` that the current state was for.\n   */\n  operation?: Operation<Data, Variables>;\n}\n\n/** Triggers {@link useSubscription} to reexecute a GraphQL subscription operation.\n *\n * @param opts - optionally, context options that will be merged with the hook's\n * {@link UseSubscriptionArgs.context} options and the `Client`’s options.\n *\n * @remarks\n * When called, {@link useSubscription} will restart the GraphQL subscription\n * operation it currently holds. If {@link UseSubscriptionArgs.pause} is set\n * to `true`, it will start executing the subscription.\n *\n * ```ts\n * const [result, executeSubscription] = useSubscription({\n *   query,\n *   pause: true,\n * });\n *\n * const start = () => {\n *   executeSubscription();\n * };\n * ```\n */\nexport type UseSubscriptionExecute = (opts?: Partial<OperationContext>) => void;\n\n/** Result tuple returned by the {@link useSubscription} hook.\n *\n * @remarks\n * Similarly to a `useState` hook’s return value,\n * the first element is the {@link useSubscription}’s state,\n * a {@link UseSubscriptionState} object,\n * and the second is used to imperatively re-execute or start the subscription\n * via a {@link UseMutationExecute} function.\n */\nexport type UseSubscriptionResponse<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = [UseSubscriptionState<Data, Variables>, UseSubscriptionExecute];\n\n/** Hook to run a GraphQL subscription and get updated GraphQL results.\n *\n * @param args - a {@link UseSubscriptionArgs} object, to pass a `query`, `variables`, and options.\n * @param handler - optionally, a {@link SubscriptionHandler} function to combine multiple subscription results.\n * @returns a {@link UseSubscriptionResponse} tuple of a {@link UseSubscriptionState} result, and an execute function.\n *\n * @remarks\n * `useSubscription` allows GraphQL subscriptions to be defined and executed.\n * Given {@link UseSubscriptionArgs.query}, it executes the GraphQL subscription with the\n * context’s {@link Client}.\n *\n * The returned result updates when the `Client` has new results\n * for the subscription, and `data` is updated with the result’s data\n * or with the `data` that a `handler` returns.\n *\n * @example\n * ```ts\n * import { gql, useSubscription } from 'urql';\n *\n * const NotificationsSubscription = gql`\n *   subscription { newNotification { id, text } }\n * `;\n *\n * const combineNotifications = (notifications = [], data) => {\n *   return [...notifications, data.newNotification];\n * };\n *\n * const Notifications = () => {\n *   const [result, executeSubscription] = useSubscription(\n *     { query: NotificationsSubscription },\n *     combineNotifications,\n *   );\n *   // ...\n * };\n * ```\n */\nexport function useSubscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest(args.query, args.variables as Variables);\n\n  const handlerRef = React.useRef<\n    SubscriptionHandler<Data, Result> | undefined\n  >(handler);\n  handlerRef.current = handler;\n\n  const source = React.useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = React.useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  React.useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      deferDispatch(setState, state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: !!source });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = React.useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      deferDispatch(setState, state => [source, state[1], deps]);\n    },\n    [client, args.context, request]\n  );\n\n  return [currentResult, executeSubscription];\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables, DocumentInput } from '@urql/core';\n\nimport { useMutation, UseMutationState, UseMutationExecute } from '../hooks';\n\n/** Props accepted by {@link Mutation}.\n *\n * @remarks\n * `MutationProps` are the props accepted by the {@link Mutation} component.\n *\n * The result, the {@link MutationState} object, will be passed to\n * a {@link MutationProps.children} function, passed as children\n * to the `Mutation` component.\n */\nexport interface MutationProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> {\n  /* The GraphQL mutation document that {@link useMutation} will execute. */\n  query: DocumentInput<Data, Variables>;\n  children(arg: MutationState<Data, Variables>): ReactElement<any>;\n}\n\n/** Object that {@link MutationProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseMutationstate} with an added\n * {@link MutationState.executeMutation} method, which is usually\n * part of a tuple returned by {@link useMutation}.\n */\nexport interface MutationState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseMutationState<Data, Variables> {\n  /** Alias to {@link useMutation}’s `executeMutation` function. */\n  executeMutation: UseMutationExecute<Data, Variables>;\n}\n\n/** Component Wrapper around {@link useMutation} to run a GraphQL query.\n *\n * @remarks\n * `Mutation` is a component wrapper around the {@link useMutation} hook\n * that calls the {@link MutationProps.children} prop, as a function,\n * with the {@link MutationState} object.\n */\nexport function Mutation<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: MutationProps<Data, Variables>): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables } from '@urql/core';\n\nimport {\n  useQuery,\n  UseQueryArgs,\n  UseQueryState,\n  UseQueryExecute,\n} from '../hooks';\n\n/** Props accepted by {@link Query}.\n *\n * @remarks\n * `QueryProps` are the props accepted by the {@link Query} component,\n * which is identical to {@link UseQueryArgs}.\n *\n * The result, the {@link QueryState} object, will be passed to\n * a {@link QueryProps.children} function, passed as children\n * to the `Query` component.\n */\nexport type QueryProps<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> = UseQueryArgs<Variables, Data> & {\n  children(arg: QueryState<Data, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link QueryProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseQueryState} with an added\n * {@link QueryState.executeQuery} method, which is usually\n * part of a tuple returned by {@link useQuery}.\n */\nexport interface QueryState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseQueryState<Data, Variables> {\n  /** Alias to {@link useQuery}’s `executeQuery` function. */\n  executeQuery: UseQueryExecute;\n}\n\n/** Component Wrapper around {@link useQuery} to run a GraphQL query.\n *\n * @remarks\n * `Query` is a component wrapper around the {@link useQuery} hook\n * that calls the {@link QueryProps.children} prop, as a function,\n * with the {@link QueryState} object.\n */\nexport function Query<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n>(props: QueryProps<Data, Variables>): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { AnyVariables } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  UseSubscriptionExecute,\n  SubscriptionHandler,\n} from '../hooks';\n\n/** Props accepted by {@link Subscription}.\n *\n * @remarks\n * `SubscriptionProps` are the props accepted by the {@link Subscription} component,\n * which is identical to {@link UseSubscriptionArgs} with an added\n * {@link SubscriptionProps.handler} prop, which {@link useSubscription} usually\n * accepts as an additional argument.\n *\n * The result, the {@link SubscriptionState} object, will be passed to\n * a {@link SubscriptionProps.children} function, passed as children\n * to the `Subscription` component.\n */\nexport type SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n> = UseSubscriptionArgs<Variables, Data> & {\n  handler?: SubscriptionHandler<Data, Result>;\n  children(arg: SubscriptionState<Result, Variables>): ReactElement<any>;\n};\n\n/** Object that {@link SubscriptionProps.children} is called with.\n *\n * @remarks\n * This is an extented {@link UseSubscriptionState} with an added\n * {@link SubscriptionState.executeSubscription} method, which is usually\n * part of a tuple returned by {@link useSubscription}.\n */\nexport interface SubscriptionState<\n  Data = any,\n  Variables extends AnyVariables = AnyVariables\n> extends UseSubscriptionState<Data, Variables> {\n  /** Alias to {@link useSubscription}’s `executeMutation` function. */\n  executeSubscription: UseSubscriptionExecute;\n}\n\n/** Component Wrapper around {@link useSubscription} to run a GraphQL subscription.\n *\n * @remarks\n * `Subscription` is a component wrapper around the {@link useSubscription} hook\n * that calls the {@link SubscriptionProps.children} prop, as a function,\n * with the {@link SubscriptionState} object.\n */\nexport function Subscription<\n  Data = any,\n  Result = Data,\n  Variables extends AnyVariables = AnyVariables\n>(props: SubscriptionProps<Data, Result, Variables>): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"],"names":["OBJ","Context","React","createContext","Provider","Consumer","displayName","useClient","client","useContext","process","env","NODE_ENV","error","console","Error","initialState","fetching","stale","undefined","data","extensions","operation","areOperationsEqual","a","b","key","computeNextState","prevState","result","newState","isShallowDifferent","hasDepsChanged","i","l","length","reactSharedInternals","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","deferDispatch","setState","value","ReactCurrentOwner","current","Promise","resolve","then","useMutation","query","isMounted","useRef","state","useState","executeMutation","useCallback","variables","context","toPromise","take","filter","hasNext","onPush","createRequest","useEffect","useRequest","prev","useMemo","request","getCacheForClient","_react","reclaim","Set","map","Map","operations$","subscribe","kind","has","delete","get","set","dispose","add","isSuspense","suspense","useQuery","args","cache","source","pause","executeQuery","requestPolicy","getSnapshot","subscription","_result","takeWhile","promise","_resolve","unsubscribe","deps","currentResult","hasResult","updateResult","nextResult","onEnd","opts","useSubscription","handler","handlerRef","executeSubscription","Mutation","props","mutation","children","Query","Subscription"],"mappings":"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"}