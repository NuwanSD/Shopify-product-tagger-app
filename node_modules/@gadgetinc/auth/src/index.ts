import type { OAuth2Namespace, OAuth2Token as Token } from "@fastify/oauth2";
import oauth2 from "@fastify/oauth2";
import type { AnyClient, AnyModelManager, GadgetRecordImplementation } from "@gadgetinc/api-client-core";
import type { FastifyInstance, FastifyReply, FastifyRequest, HookHandlerDoneFunction } from "fastify";
import fp from "fastify-plugin";
import jwt from "jsonwebtoken";

declare module "fastify" {
  interface FastifyInstance {
    googleOAuth2: OAuth2Namespace;
  }

  interface FastifyReply {
    view: (page: string, data?: object) => Promise<string>;
  }

  interface FastifyRequest {
    gadgetAuth?: Partial<GadgetAuthOptions<any>>;
  }
}

export type Providers<UserInput> = {
  type: "google";
  clientId: string;
  clientSecret: string;
  transformUser?: (result: GoogleOAuthResult) => UserInput;
  scopes?: string[];
  signedInRoles?: string[];
};

/**
 * Options for the Gadget auth plugin
 * @property {Providers} providers The providers to use for authentication
 * @property {string[]} signedInRoles The roles to assign a session that is signed in
 * @property {AnyClient} api The Gadget API client to use for creating and updating users and sessions
 * @property {string} loginPath The path to redirect to when a route is protected and the user is not signed in. Defaults to `/login`.
 * @property {boolean} redirectToLogin Whether to redirect to the login path when a route is protected and the user is not signed in. Defaults to `false`.
 */
export type GadgetAuthOptions<UserInput> = {
  providers: Providers<UserInput>[];
  signedInRoles: string[];
  api: AnyClient;
  signInPath?: string;
  redirectToSignIn?: boolean;
};

type GoogleOAuthResult = {
  given_name: string;
  family_name: string;
  email: string;
  email_verified: string;
  name: string;
  picture: string;
  profile: string;
};

interface Session {
  get(key: string): any;
  set(key: string, value: any): void;
}

const getSessionFromRequest = <Request extends FastifyRequest>(request: Request): Session => {
  if ("applicationSession" in request) {
    return request.applicationSession as Session;
  }

  throw new Error("The request is not a Gadget server request");
};

/**
 * Utility function to wrap route handlers with protection from unauthenticated requests.
 *
 * @param handler The route handler to protect
 * @param {ProtectedRouteOptions} options Options for the protected route
 * @returns handler function that is wrapped with route protection
 *
 * @example
 * ```ts
 * // routes/GET-protected-route.js
 * const { preValidation } = require("@gadgetinc/auth");
 *
 * module.exports = async ({ request, reply }) => {
 *  await reply.send("this is a protected route");
 * }
 *
 * module.options = {
 *  preValidation,
 * }
 * ```
 */
export const preValidation = async <RouteContext extends FastifyRequest>(request: RouteContext, reply: FastifyReply) => {
  let authenticated = false;
  const applicationSession = getSessionFromRequest(request);
  authenticated = !!applicationSession.get("user");

  if (!authenticated) {
    if (request.gadgetAuth?.redirectToSignIn) {
      await reply.redirect(request.gadgetAuth.signInPath);
    } else {
      await reply.status(403).send();
    }
  }
};

interface BaseUserInput {
  email: string;
  firstName: string;
  lastName: string;
  googleImageUrl: string;
}

/**
 * Fastify auth plugin for Gadget apps. This plugin will register route handlers for the specified providers and handle creating/updating users and sessions.
 * @param {FastifyInstance} fastify instance of fastify server
 * @param {GadgetAuthOptions} options options for the auth plugin
 * @param {HookHandlerDoneFunction} done hook handler done function when plugin is registered
 *
 * @example
 * ```ts
 * import { Auth } from "@gadgetinc/auth";
 * import { Client } from "@gadget-client/my-app";
 *
 * const api = new Client({
 *  authenticationMode: {
 *   apiKey: "my-api-key",
 *  }
 * });
 *
 * export default function(server) {
 *  server.register(Auth, {
 *   signedInRoles: ["signed-in"],
 *   api,
 *   providers: [
 *    {
 *      type: "google",
 *      clientId: process.env.GOOGLE_CLIENT_ID,
 *      clientSecret: process.env.GOOGLE_CLIENT_SECRET,
 *    }
 *   ],
 *  });
 * }
 * ```
 */
export const Auth = fp(
  <UserInput extends BaseUserInput>(fastify: FastifyInstance, options: GadgetAuthOptions<UserInput>, done: HookHandlerDoneFunction) => {
    if (options.providers.length > 0) {
      const googleProvider = options.providers[0];

      if (googleProvider.type !== "google") {
        done(new Error("Provider type must be `google`"));
        return;
      }

      if (!("user" in options.api)) {
        done(new Error("A user model must exist"));
        return;
      }

      const userManager = options.api.user as AnyModelManager & {
        create?: (input: BaseUserInput) => Promise<GadgetRecordImplementation<any>>;
        update?: (id: string, input: Partial<BaseUserInput>) => Promise<GadgetRecordImplementation<any>>;
      };

      if (!("create" in userManager)) {
        done(new Error("User model must have a create action"));
        return;
      }

      if (!("update" in userManager)) {
        done(new Error("User model must have an update action"));
        return;
      }

      fastify.addHook("onRequest", (request: FastifyRequest, _reply: FastifyReply, done: HookHandlerDoneFunction) => {
        request.gadgetAuth = {
          redirectToSignIn: options.redirectToSignIn ?? false,
          signInPath: options.signInPath ?? "/signin",
        };
        done();
      });

      // api root urls aren't exposed on AnyClient. The type cast to any can be removed once we add the types
      const appUrl = new URL(
        process.env.NODE_ENV === "production" ? (options.api as any).productionApiRoot : (options.api as any).developmentApiRoot
      );

      fastify.get("/auth/google/callback", async function <
        RouteContext extends FastifyRequest
      >(this: FastifyInstance, request: RouteContext, reply: FastifyReply) {
        const token: Token & { id_token?: string } = await this.googleOAuth2.getAccessTokenFromAuthorizationCodeFlow(request);

        if (!token.id_token) {
          await reply.status(400).send();
          return;
        }

        const decoded = jwt.decode(token.id_token) as GoogleOAuthResult | null;

        if (!decoded) {
          await reply.status(400).send();
          return;
        }

        let claims: Record<string, any>;

        if (typeof decoded === "string") {
          claims = JSON.parse(decoded);
        } else {
          claims = decoded;
        }

        const { email, family_name, given_name, picture } = claims;
        const user = await userManager.maybeFindFirst({
          filter: {
            email: {
              equals: email,
            },
          },
        });
        const applicationSession = getSessionFromRequest(request);

        if (user) {
          const existingUserId = user.getField("id");
          applicationSession?.set("user", existingUserId);

          if (googleProvider.transformUser) {
            await userManager.update(existingUserId, googleProvider.transformUser(decoded));
          } else {
            await userManager.update(existingUserId, {
              firstName: String(given_name),
              lastName: String(family_name),
            });
          }
        } else {
          let newUser: GadgetRecordImplementation<any>;

          if (googleProvider.transformUser) {
            newUser = await userManager.create(googleProvider.transformUser(decoded));
          } else {
            newUser = await userManager.create({
              email: String(email),
              firstName: String(given_name),
              lastName: String(family_name),
              googleImageUrl: String(picture),
            });
          }

          applicationSession?.set("user", newUser.getField("id"));
        }
        applicationSession?.set("roles", googleProvider.signedInRoles ?? options.signedInRoles);

        await reply.redirect("/");
      });

      if (!googleProvider.clientId || !googleProvider.clientSecret) {
        fastify.get("/auth/google/start", async (request: FastifyRequest, reply: FastifyReply) => {
          void reply.header("Content-Type", "text/html");
          await reply.status(400).send(`
        <!DOCTYPE html>
        <html>
          <head>
            <link rel="preconnect" href="https://fonts.googleapis.com">
            <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
            <link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@700&family=Inter:wght@400;700&display=swap" rel="stylesheet">
            <title>Google OAuth2 Error</title>
            <style>
              body {
                height: 100vh;
                width: 100vw;
                font-family: Inter, sans-serif;
                margin: 0;
              }
              .error-wrapper {
                display: flex;
                flex-direction: column;
                gap: 32px;
                padding: 64px;
                height: 100%;
                align-items: center;
                justify-content: center;
                box-sizing: border-box;
              }
              code {
                background-color: #EEEEEE;
                padding: 4px 8px;
                border-radius: 4px;
                font-weight: 700;
                font-family: Inconsolata, monospace;
                margin: 0 5px;
              }
              a {
                text-decoration: underline;
                color: black;
              }
              .error-wrapper h2 {
                text-align: center;
                margin: 0;
              }
              .error-wrapper .content {
                text-align: center;
                max-width: 500px;
                line-height: 25px;
              }
            </style>
          </head>
          <body>
            <div class="error-wrapper">
              <svg width="64" height="64" viewBox="0 0 20 20" xmlns="http://www.w3.org/2000/svg">
                <path
                  d="M9.99992 2C9.44554 2 8.97063 2.33782 8.76945 2.81901L1.53377 15.2982V15.2995C1.40319 15.5098 1.33375 15.7524 1.33325 16C1.33325 16.3536 1.47373 16.6928 1.72378 16.9428C1.97382 17.1929 2.31296 17.3333 2.66659 17.3333C2.69787 17.3331 2.72914 17.3318 2.76034 17.3294L2.76294 17.3333H9.99992H17.2369L17.2395 17.3281C17.2707 17.331 17.3019 17.3327 17.3333 17.3333C17.6869 17.3333 18.026 17.1929 18.2761 16.9428C18.5261 16.6928 18.6666 16.3536 18.6666 16C18.6663 15.752 18.5969 15.5089 18.4661 15.2982L18.4556 15.2799C18.4552 15.2795 18.4548 15.2791 18.4543 15.2786L11.2304 2.81901C11.0292 2.33782 10.5543 2 9.99992 2ZM9.19132 7.57292H10.8085L10.6744 11.888H9.32544L9.19132 7.57292ZM10.0025 13.207C10.5505 13.207 10.8788 13.5019 10.8788 14.0052C10.8788 14.4992 10.5505 14.793 10.0025 14.793C9.45052 14.793 9.11971 14.4992 9.11971 14.0052C9.11971 13.5019 9.44986 13.207 10.0025 13.207Z"
                />
              </svg>
              <h2>Google OAuth2 credentials are not configured.</h2>
              <div class="content">
                Set up your <code>GOOGLE_CLIENT_ID</code> and <code>GOOGLE_CLIENT_SECRET</code><br>
                in the <a href="/edit/settings/env">environment variables</a> of your app, then try again.
              </div>
            </div>
          </body>
        </html>
        `);
        });

        done();
      } else {
        oauth2(
          fastify,
          {
            name: "googleOAuth2",
            scope: googleProvider.scopes ?? ["profile", "email"],
            credentials: {
              client: {
                id: googleProvider.clientId,
                secret: googleProvider.clientSecret,
              },
              auth: oauth2.GOOGLE_CONFIGURATION,
            },
            callbackUri: `${appUrl.origin}/auth/google/callback`,
            startRedirectPath: "/auth/google/start",
          },
          done
        );
      }
    }

    fastify.post("/auth/signout", async function <RouteContext extends FastifyRequest>(request: RouteContext, reply: FastifyReply) {
      const applicationSession = getSessionFromRequest(request);
      await options.api.internal.session.delete(applicationSession?.get("id"));
      await reply.redirect("/");
    });
  },
  {
    fastify: "3.x",
  }
);
