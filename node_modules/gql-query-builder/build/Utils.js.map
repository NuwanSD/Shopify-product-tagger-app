{"version":3,"file":"Utils.js","sourceRoot":"","sources":["../src/Utils.ts"],"names":[],"mappings":"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","sourcesContent":["import Fields from \"./Fields\";\nimport IQueryBuilderOptions from \"./IQueryBuilderOptions\";\nimport NestedField, { isNestedField } from \"./NestedField\";\nimport VariableOptions from \"./VariableOptions\";\n\nexport default class Utils {\n  public static resolveVariables(operations: IQueryBuilderOptions[]): any {\n    let ret: any = {};\n\n    for (const { variables, fields } of operations) {\n      ret = {\n        ...ret,\n        ...variables,\n        ...((fields && Utils.getNestedVariables(fields)) || {}),\n      };\n    }\n    return ret;\n  }\n\n  // Convert object to name and argument map. eg: (id: $id)\n  public static queryDataNameAndArgumentMap(variables: VariableOptions) {\n    return variables && Object.keys(variables).length\n      ? `(${Object.entries(variables).reduce((dataString, [key, value], i) => {\n          return `${dataString}${i !== 0 ? \", \" : \"\"}${\n            value && value.name ? value.name : key\n          }: $${key}`;\n        }, \"\")})`\n      : \"\";\n  }\n\n  public static queryFieldsMap(fields?: Fields): string {\n    return fields\n      ? fields\n          .map((field) => {\n            if (isNestedField(field)) {\n              return Utils.queryNestedFieldMap(field);\n            } else if (typeof field === \"object\") {\n              let result = \"\";\n\n              Object.entries<Fields>(field as Record<string, Fields>).forEach(\n                ([key, values], index, array) => {\n                  result += `${key} ${\n                    values.length > 0\n                      ? \"{ \" + this.queryFieldsMap(values) + \" }\"\n                      : \"\"\n                  }`;\n\n                  // If it's not the last item in array, join with comma\n                  if (index < array.length - 1) {\n                    result += \", \";\n                  }\n                }\n              );\n\n              return result;\n            } else {\n              return `${field}`;\n            }\n          })\n          .join(\", \")\n      : \"\";\n  }\n\n  public static operationOrAlias(\n    operation: IQueryBuilderOptions[\"operation\"]\n  ): string {\n    return typeof operation === \"string\"\n      ? operation\n      : `${operation.alias}: ${operation.name}`;\n  }\n\n  public static isFragment(field: NestedField): boolean {\n    return field?.fragment === true ?? false;\n  }\n\n  public static operationOrFragment(field: NestedField): string {\n    return Utils.isFragment(field)\n      ? field.operation\n      : Utils.operationOrAlias(field.operation);\n  }\n\n  public static getFragment(field: NestedField): string {\n    return Utils.isFragment(field) ? \"... on \" : \"\";\n  }\n\n  public static queryNestedFieldMap(field: NestedField) {\n    return `${Utils.getFragment(field)}${Utils.operationOrFragment(field)} ${\n      this.isFragment(field)\n        ? \"\"\n        : this.queryDataNameAndArgumentMap(field.variables)\n    } ${\n      field.fields.length > 0\n        ? \"{ \" + this.queryFieldsMap(field.fields) + \" }\"\n        : \"\"\n    }`;\n  }\n\n  // Variables map. eg: { \"id\": 1, \"name\": \"Jon Doe\" }\n  public static queryVariablesMap(variables: any, fields?: Fields) {\n    const variablesMapped: { [key: string]: unknown } = {};\n    const update = (vars: any) => {\n      if (vars) {\n        Object.keys(vars).map((key) => {\n          variablesMapped[key] =\n            typeof vars[key] === \"object\" ? vars[key].value : vars[key];\n        });\n      }\n    };\n\n    update(variables);\n    if (fields && typeof fields === \"object\") {\n      update(Utils.getNestedVariables(fields));\n    }\n    return variablesMapped;\n  }\n\n  public static getNestedVariables(fields: Fields) {\n    let variables = {};\n\n    function getDeepestVariables(innerFields: Fields) {\n      innerFields?.forEach((field: string | object | NestedField) => {\n        if (isNestedField(field)) {\n          variables = {\n            ...field.variables,\n            ...variables,\n            ...(field.fields && getDeepestVariables(field.fields)),\n          };\n        } else {\n          if (typeof field === \"object\") {\n            for (const [, value] of Object.entries(field)) {\n              getDeepestVariables(value);\n            }\n          }\n        }\n      });\n\n      return variables;\n    }\n\n    getDeepestVariables(fields);\n\n    return variables;\n  }\n\n  public static queryDataType(variable: any) {\n    let type = \"String\";\n\n    const value = typeof variable === \"object\" ? variable.value : variable;\n\n    if (variable?.type != null) {\n      type = variable.type;\n    } else {\n      // TODO: Should handle the undefined value (either in array value or single value)\n      const candidateValue = Array.isArray(value) ? value[0] : value;\n      switch (typeof candidateValue) {\n        case \"object\":\n          type = \"Object\";\n          break;\n\n        case \"boolean\":\n          type = \"Boolean\";\n          break;\n\n        case \"number\":\n          type = candidateValue % 1 === 0 ? \"Int\" : \"Float\";\n          break;\n      }\n    }\n\n    // set object based variable properties\n    if (typeof variable === \"object\") {\n      if (variable.list === true) {\n        type = `[${type}]`;\n      } else if (Array.isArray(variable.list)) {\n        type = `[${type}${variable.list[0] ? \"!\" : \"\"}]`;\n      }\n\n      if (variable.required) {\n        type += \"!\";\n      }\n    }\n\n    return type;\n  }\n}\n"]}